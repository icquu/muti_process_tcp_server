# [MySQL 事务隔离级别](https://www.cnblogs.com/geaozhang/p/10478918.html)

一、事务描述

1、事务的四个特性 ACID

　　1. A：原子性 = 一个事务或者都成功、或者都失败；

　　2. C：一致性 = 在整个事务的生命周期里面，查询到的数据是一致的；

　　　　MVCC多版本并发控制：利用undo保存某一时刻数据快照，通过版本号来减少锁的争用，保证各个事务互不影响。

　　3. I：  隔离性 = 隔离级别；

　　4. D：持久性 = 只要事务commit，这个事务不会因为系统的崩溃而丢失；

　　持久性和原子性对于所有的支持事务的数据库都是一样的，都满足。

2、常见事务格式

> start transaction;
>
> 　　DML ( insert; delete; update; )
>
> commit;

3、MySQL 默认每一条 DML 是一个事务

　　通过参数 'autocommit' 进行控制是否默认提交事务；

```
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.01 sec)
```

SQL 自动提交开启，有一定的危险性(没有 rollback )。

　　墙裂推荐：关闭 SQL 的自动提交；

　　血泪教训：曾经自信过了头的一次 sitesup （其实也是有反复确认），同时疏忽了备份，命令行下一个回车敲下去，发现问题大发了……所以，备份 + 显式 Commit 很重要。

4、大事务+长事务

　　数据库的大事务和长事务会带来undo的持续增加、undo暴增，空间不可复用；

　　事务信息表：information_schema.INNODB_TRX，用来查看长事务、大事务。

5、空闲事务+锁

> start transaction;
>
> 　　update;
>
> 　　……    // 空闲等待，时间可能不可控
>
> 　　……    // 空闲等待
>
> 　　update;
>
> commit;

　　1. 事务和事务锁有一定的关系：事务不提交、行锁就不会释放、事务锁就不会消失

　　2. 死锁：是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种相互等待的现象。死锁出现的概率是非常低的，因为innodb内置有死锁检查机制，当出现死锁时会自动回滚占用undo资源少的事务。

 

二、事务隔离级别

0、隔离性

　　1. MySQL 有多个隔离级别，可以调整，隔离性越弱并发性越好；

　　2. 每个数据库都有自己默认的隔离级别

```
mysql> show variables like '%iso%';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| tx_isolation  | REPEATABLE-READ |
+---------------+-----------------+
1 row in set (0.01 sec)
```

 　　会话级别设置：set @@session.tx_isolation=……

1、READ-UNCOMMITED

　　未提交读，隔离性最弱，但并发性最好；

　　事务中的修改，即使没有提交，对其他事务也都是可见的，也就是说事务可以读取未提交的数据，读到脏数据(脏读，dirty read)；

2、READ-COMMITED

　　大部分数据库系统的默认隔离级别都是READ-COMMITED，但MySQL不是；

　　1. 提交读，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的；

　　2. 不可重复读，在同一个事务中，同一个SQL执行多次(该记录修改事务提交前、提交后)，得到的结果可能不同：幻读；

3、REPEATABLE-READ

　　可重复读，MySQL默认隔离级别；

　　在同一个事务中，同一个SQL执行多次，得到的结果是相同的；

　　1. 对于普通 select 来说，通过 MVCC 来实现，解决脏读问题、幻读问题；

　　2. 对于 dml、select for update，通过范围锁实现，解决幻读问题；

4、SERIALIZABLE

　　(serializable 连载、串行化) 隔离性最高，没有并发；

　　对于同一个数据来说，在同一个时间段内，只能有一个会话可以访问，包括select和dml，通过执行事务串行执行，避免幻读问题；

　　也就是说，对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

　　注意：业务有串行化的需求，但是我们不会设置数据库事务为串行化隔离级别，而是在应用端设置解决(例：U盾)。